"""
Implementation of a deep convolutional neural network for denoising images based on the
paper by Zhang et al. [https://www.ncbi.nlm.nih.gov/pubmed/28166495]

The authors' original implementation can be found here [https://github.com/cszn/DnCNN].

Isak Persson
Wei Hu

22 July 2019
"""


import random
import tensorflow as tf
import utils

from models.dncnn_model import cnn_model_fn


EPOCHS = 10000
LR = 0.001  # Updated using Adam Optimizer
BATCH_SIZE = 128
STDV = 25  # The standard deviation used for the gaussian noise.
N_EVAL = 20  # Number of test to run per evaluation.


def train(loss, original, noisy_image, output, summary):
    """ The main procedure for training the model. On every tenth step, statistics about
    the how the training is progressing is printed out.

    Args:
        loss: the loss function which the model is aiming to minimize.
        original: the original image which is composed of a batch of patches.
        noisy_image: the original image with Gaussian noise added.
        output: the noise generated by the neural network.
    """
    # Configures the Training Op
    train_op = tf.compat.v1.train.AdamOptimizer(learning_rate=LR).minimize(
        loss=loss, global_step=tf.compat.v1.train.get_global_step()
    )

    with tf.compat.v1.Session() as sess:

        if ARGS.initialize:
            sess.run(tf.global_variables_initializer())
        else:
            tf.compat.v1.train.Saver().restore(sess, "./models/trained/dncnn.ckpt")

        writer = tf.summary.FileWriter("./log/dncnn", sess.graph)

        for step in range(EPOCHS):

            # Runs training process.
            _, _loss = sess.run([train_op, loss])

            if step % 10 == 0:
                # Log the current training status.
                _psnr, _max, _min, _summary = sess.run(
                    [
                        utils.psnr(
                            tf.squeeze(original), tf.squeeze(noisy_image - output)
                        ),
                        tf.reduce_max(output),
                        tf.reduce_min(output),
                        summary,
                    ]
                )

                writer.add_summary(_summary, step)

                print(
                    "Step "
                    + str(step)
                    + ", Minibatch Loss = "
                    + "{:.8f}".format(_loss)
                    + ", PSNR = "
                    + "{:.4f}".format(_psnr)
                    + ", Brightest Pixel = "
                    + "{:.4f}".format(_max * 255)
                    + ", Darkest Pixel = "
                    + "{:.4f}".format(_min * 255)
                )
                # Serialize trained network and the progression of loss values.
                tf.compat.v1.train.Saver().save(sess, "./models/trained/dncnn.ckpt")


def evaluate(loss, input_image, original, noisy_image, output):
    """ A random test image is selected (only a portion of which the network has seen).
    Noise is added to the image which is then fed to the network. We preserve the
    generated noisy image, the noise the network produced, and the denoised image. We
    also output the loss and the PSNR.

    Args:
        loss: the loss function which the model is aiming to minimize.
        input_image: a placeholder which will be fed the path of the test image.
        original: the original test image.
        noisy_image: the original image with Gaussian noise added.
        output: the noise generated by the neural network.
    """
    with tf.compat.v1.Session() as sess:

        tf.compat.v1.train.Saver().restore(sess, "./models/trained/dncnn.ckpt")

        sample_image = random.choice(utils.TESTS)

        _psnr, _loss = sess.run(
            [utils.psnr(tf.squeeze(original), tf.squeeze(noisy_image - output)), loss],
            feed_dict={input_image: sample_image},
        )
        print("Loss = " + "{:.8f}".format(_loss) + ", PSNR = " + "{:.4f}".format(_psnr))

        # Preserves the output of the cnn (the generated noise).
        noise_writer = utils.write_image(
            "./outputs/dncnn/generated_noise" + sample_image[-7:],
            utils.unscale(tf.squeeze(output, axis=0)),
        )

        # Preserves the denoised image (the noisy image minus the generated noise).
        denoised_writer = utils.write_image(
            "./outputs/dncnn/denoised_image" + sample_image[-7:],
            utils.unscale(tf.squeeze(noisy_image - output, axis=0)),
        )

        # Preserves the original noisy image.
        noisy_image_writer = utils.write_image(
            "./outputs/dncnn/noisy_image" + sample_image[-7:],
            utils.unscale(noisy_image),
        )

        sess.run(
            [noisy_image_writer, noise_writer, denoised_writer],
            feed_dict={input_image: sample_image},
        )


def main():
    """ Implements the deep convolutional neural network for denoising images based on
    the paper by Zhang et al.

    There are two modes. During training mode, the model takes in a batch of 64 by 64
    image patches from the training set. During evaluation mode, the the model attempts
    to denoise images of varying sizes from the test set.
    """
    if not ARGS.train:
        input_image = tf.compat.v1.placeholder(tf.string)
        original = utils.load_and_preprocess_image(input_image)
    else:
        iterator = utils.create_dataset_iterator(utils.PATCHES, BATCH_SIZE)
        original = iterator.get_next()

    # Generates Gaussian noise and adds it to the image.
    noise = utils.scale(utils.gaussian_noise(tf.shape(original), 0, STDV))
    noisy_image = original + noise

    # Inputs noisy image into the neural network.
    if not ARGS.train:
        output = cnn_model_fn(noisy_image)
        noise = tf.expand_dims(noise, 0)
    else:
        output = cnn_model_fn(noisy_image)

    # Calculates loss by comparing pixel-wise differences.
    loss = tf.compat.v1.losses.mean_squared_error(labels=noise, predictions=output)

    # Trains the model.
    if not ARGS.train:
        for _ in range(N_EVAL):
            evaluate(loss, input_image, original, noisy_image, output)

    else:
        image_summaries = {
            "Original Image": original,
            "Noisy Image": noisy_image,
            "Generated Noise": output,
            "Denoised Image": noisy_image - output,
        }
        scalar_summaries = {
            "PSNR": utils.psnr(tf.squeeze(original), tf.squeeze(noisy_image - output)),
            "Loss": loss,
        }
        # Creates a summary to be displayed on TensorBoard.
        summary = utils.create_summary(image_summaries, scalar_summaries)
        train(loss, original, noisy_image, output, summary)


if __name__ == "__main__":
    ARGS = utils.get_args()
    main()
